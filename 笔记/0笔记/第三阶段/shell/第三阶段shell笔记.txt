

3月23 day01



一、编写及执行shell脚本

	1.什么是shell？
		命令行解释器 	
		通常指/bin/bash		
		
	2.什么是脚本？
		实现某种功能的有执行权限的文件（用什么语言写就是什么脚本！）

	3.怎么写shell脚本？
	     vim  名.sh
		#!/bin/bash
		功能代码
		：wq
	
	4.怎么执行shell脚本？
		chmod +x 名.sh
		./名.sh		#相对路径
		/etc/init.d/名.sh	#绝对路径
		
		sh /etc/init.d/名.sh	#专属解释器执行
		bash /etc/init.d/名.sh

	     #执行脚本时，不分配新的资源来执行脚本，而是占用当前终端的资源运行脚本。
		source /etc/init.d/名.sh
		.  /etc/init.d/名.sh
	     #资源：内存，CPU

	5.shell特性?
		type vim	#查看vim是否是shell内嵌的
		支持快捷键，Tab键补齐
		历史命令 ： history
		命令别名 ： alias	系统级（所有用户）：/etc/bashrc	  用户级：～/.bashrc
		重定向：改变输出的设备


	6.如何查看系统支持的shell?
		cat /etc/shells

   #############################################################################################

二、shell变量*

	1.什么是变量？
		用固定的字符串来存储变化的数据

	2.定义变量
		变量名=值

	3.变量的使用规则 及变量名的命名规则
		赋值时，=号两边不能有空格
		变量名不能为纯数字和不能以数字开头
		变量名只能用 { _ 数字 大小字母}，且区分大小写

	4.使用变量
		$变量名

	5.输出变量值
		echo $变量名

	6.查看已经定义的变量 ：env 只看系统环境变量
				 set 看系统环境变量和自定义变量

	7.销毁变量
		unset 变量名

	8.shell变量类型
	**	系统环境变量：系统启动时读取系统配置文件或服务的配置文件，定义的变量。（可以在脚本中直接调用，也可修改）
				变量名和存储的值是固定的，值会根据系统的运行环境和配置自动获取。（变量名常用大写表示）
		$PATH 	$PWD		 $USER	 $HOME
		$HOSTNAME	$SHELL	 $MAIL


	**	预定义变量：  /bin/bash 这种shell程序内值的变量，变量值是根据系统环境自动获取。
				$0：当前所在的进程或脚本名
				$$：当前运行程序的PID号		
				$#：显示输入的位置变量的个数
				$*：显示所有位置变量的值
				$!：查看当前终端后台进程的PID号
				$?：命令执行后的返回状态，0表示执行正常，1或其他值表示异常

	**	位置变量： $1  $2  $3 ... $9  ${10}  ${11} ...
			   如果写成$11 ==$1的值连上1  如：$1=a, $11=a1


		自定义变量：编写脚本时，根据程序的需要定义的变量，要遵循变量的使用规则。（变化的数据用变量表示）

	9.给变量赋值的方式？
		普通赋值： x=19

		从键盘接受数据给变量赋值：read -p "提示信息" -t 10 变量名

		使用一个变量给另一个变量赋值：
		x=3  y=8	  z=$x$y(=38)
		z=$z55$y(=8)  z=${x}55$y(=3558)

		累加赋值：变量自己给自己添加新值
		PATH=/shell4:$PATH	#把/shell4目录设置为系统环境变量，该目录下的shell脚本可以直接调用
		echo $PATH			#只在本终端有效

		获取命令的执行结果给变量赋值

	10.变量的作用范围？
		在脚本中定义的变量，只在脚本执行过程中有效。
	

	11.获取命令的执行结果给变量赋值
		变量名=$(系统命令)
		变量名=`系统命令`		# ``反撇号，将命令的执行输出结果作为变量值

		name=aaaa
		echo '$name' ==$name	# ''单引号不会解释特殊符号
		echo "$name" ==aaaa	# ""双引号会解释特殊符号


	   ·全局变量：在当前shell和其子shell里都可以使用  export:定义为全局变量。

		vim /etc/profile			#重启系统才可以打开终端直接用
		export PATH=/shell:$PATH
		:wq
		source /etc/profile		#开终端后刷新一下文件

	      第二个方法：
		vim /etc/bashrc			#每次开终端就会调用一次所以放这里
		export PATH=/shell:$PATH
		:wq

	    ·取消全局变量： -n 	export -n 变量名
	     

	   ·局部变量：只能在当前shell里使用。
	

	12.终端显示控制
		关闭输出（不显示） ：  stty -echo
		恢复输出（显示） ：  stty  echo

	   例子： 
		stty -echo 						#关闭输出显示
		read -p "请输入你的密码：  "  mypass		#输入密码时屏幕不显示
		stty  echo						#恢复输出显示


___________________________________________________________________________
————————————————————————————————————————————————————————————



3月24号 day02




一、算数运算
	1.运算符号： +  -   *   /   %   ++   --   +=   -=   *=   /=   %=
	
	2.计算表达式： 数字1   运算符号   数字2		#运算符号和数字要有空格分开

	3.运算命令:
		整数运算命令： expr  计算表达式			#默认会返回计算结果，*要加转义符\ :expr 2 \* 3

				$[计算表达式]				#默认不会返回结果，结合echo $[x + y]
				$((计算表达式))			#默认不会返回结果，得输出 echo $((x * y))
									 *不用转义  引用变量可以不用加$ 
			let  计算表达式
			  let i++ , ++i		#自加运算，i=$i+1
			  let i-- , --i		#自减运算，i=$i-1
			  let i+=3,			# i+=步长，自加，i=$i+3
			  let i-=3,			# i-=步长，自减，i=$i-3
			  let i*=5,			#

		小数运算命令： echo  "计算表达式"  |  bc


二、条件判断
	1.判断符号
	
	2.表达式

	3.判断命令： test 表达式        [ 表达式 ]：表达式左右要有空格不能挨着[ ]
		test 选项  参数  
		[ 选项 参数 ]	   



	字符比较 :	==（两个字符串相同） 
			!= （两个字符串不同）
			-z （字符串的值为空）
			-n （字符串的值不为空，相等于 !-z）	
	
		#字符表示变量时 test的参数 要加"","$name"
		"字符串1"  符号  "字符串2"
		  $name  ==   "字符串2"
	   例子：
		test -n "$name"		#判断变量name是否 不为空
		[ -n "$name" ]		#判断变量name是否 不为空

	**	# [ -z "$name" ] 		#变量name是否为空？
		# echo $?			#看返回值
		#   0				# 0 为真


	整数值比较 ：   -eq(等于)			数字1  符号  数字2
			-ne(不等于)  		  $x  -eq  9
			-ge(大于等于)
			-le(小于等于)    	
			-gt(大于)
			-lt(小于)	
		
	   例子：
		x=9				y=11
		test $x -eq 9		[ $y -gt $x ]
		echo $?			echo $?
		0				0
		


	小数值比较 ： (使用bc命令： echo " 1.5 == 1.6" | bc  值为1时真，为0时假)



	逻辑比较 ： &&(且,与)   || (或)  !(非)
		条件判断1  符号  条件判断2
	  例子：
		test 10 -eq 10 && test $USER == "root"	[ 10 -eq 10 ] && [ $USER == "root" ]
		echo $?						echo $?
		test 10 -eq 10 || test $USER == "ldj"	[ 10 -eq 9 ] || [ $USER == "root" ]
		echo $?   #值为0，只要有一个条件满足就为真	echo $?	#值为0 ，只要有一个条件满足就为真


	判断文件状态 ： -e  -d  -f  -r  -w  -x
			-e:判断对象是否存在，存在则结果为真
			-d:判断对象是否为目录，是则为真
			-f:判断对象是否为一般文件，是则为真
			-r:判断对象是否有可读权限，是则为真
			-w:判断对象是否有可写权限，是则为真
			-x:判断对象是否有可执行权限，是则为真
		选项  文件名或目录
		-e   /root
	   例子：
		test -f /etc/passwd			[ -f /etc/passwd ]
		echo $?					echo $?
		test -e /mydata				[ -e /mydata ]		
		echo $?					echo $?



三、流程控制-if判断

	1.单分支结构
		if 条件判度 ;then			if  条件判断
			命令代码。。			then
			。。。。。				命令代码行。。
		fi					fi

	2.双分支结构
		if 条件判度 ;then			if  条件判断
			命令代码。。			then
			。。。。。				命令代码行。。
		else					else
			代码。。。				代码。。。。
		fi					fi


	3.多分支结构
		if 条件判度;then			if  条件判断
			命令代码。。			then
			。。。。。				命令代码行。。
		elif 条件判断;then			elif
			代码。。。			then
			。。。。。				代码。。。。
		else					else
			代码。。。				代码。。。。
		fi					fi



___________________________________________________________________________
————————————————————————————————————————————————————————————


3月26号 day03


一、循环结构


	1.for循环		#当条件为变量时，要用`seq $变量`
		for i in 参数	for （（i=0;i<100;i++））		for i in  `seq $变量`
		do			do					do
			命令			命令
		done			done					done



	2.while循环
	
   **  while死循环时，条件设为真。
	·while ture		#可能导致性能的损失	 **	while ：	  #shell内置命令 : 它总是返回0退出码
	  do							do
		代码。。。					     代码。。。
	  done						done




	3.case结构(简化版的if)
	 ·case语句结构特点如下：
         case行尾必须为单词“in”，  每一个模式必须以右括号“）”结束。
        	双分号“;;”表示命令序列结束。
        	匹配模式中可是使用方括号表示一个连续的范围，如[0-9]；使用竖杠符号“|”表示或。
        	最后的“*）”表示默认模式，当使用前面的各种模式均无法匹配该变量时，将执行“*）”后的命令序列。

	case 变量 in
	值1)
		命令 
		;;		# ;; 命令序列结束
	值2) 
		命令 
		;;
	*）			# *可以表其他所有
		命令
	esac



二、函数：给一段代码取个别名


	1.定义函数的结构
		function 函数名{					函数名 (){
			代码段。。。						代码段。。。
		}							}

	# echo -e(扩展) "\033[32m我\033[0m"
				    3x是字体色："\033[ 35m你\033[0m"
				    4x是背景色："\033[ 45m你\033[0m"
				    0x样式："\033[ 05m你\033[0m"


	2.循环 中断及退出
		continue：结束本次循环，进入下一次循环
		brek：结束整个循环
		exit 2：结束整个脚本，可以带返回值 `echo $?`=2    ，返回值可以自定义 用于排错较多



___________________________________________________________________________
————————————————————————————————————————————————————————————


3月27号  day04



一、字符串处理

	1、字符串截取的方法

		1).使用 ${}方法 
		    -格式：${变量:启始位置:长度}
		   ${phone:2:8}  从下标为2的位置（第3个位置）开始向后截取 8个字符
		   ${phone::8} 不写启始默认从0开始

	**	   ${#phone} : 查看字符串长度

		2).使用expr 、 substr
		   -格式：expr substr $变量  起始位置  长度 
		   expr substr $phone 2 8
		    
		3).使用cut工具
		   -格式：echo $变量 | cut -b 起始位置-结束位置
		   echo $phone | cut -b 2-8

	2、字符串替换	** 替换不影响源数据值
	
		1).只替换第1个匹配结果
		   -格式： ${变量名/老/新}
		    ${phone/138/xxx}		#替换第一个值为138的字符，换为xxx

		2).替换全部匹配结果
		   -格式：${变量名//老/新}
		    ${phone//2/x}		#替换所有值为2的字符，全部换为x

	3、字符串掐头去尾

		1).掐头
		 -从左向右，最短删除
		   -格式： ${变量#*关键字}
		   echo ${phone#*:}	#从左向右删除第一个：之前的所有（*）

		 -从左向右，最长删除
		   -格式： ${变量##*关键字}
		   echo ${phone##*:}	#从左向右删除最后一个：之前的所有（*）
		
		2).去尾
		 -从右向左，最短匹配删除
		   -格式： ${变量%关键字*}
		   echo ${phone%:*}	#从右向左删除第一个：之后的所有（*）

		 -从右向左，最长匹配删除
		   -格式： ${变量%%关键字*}
		   echo ${phone%%:*}	#从右向左删除最后一个：之后的所有（*）


	4、字符串赋初始值

		1).查看变量是否定义
		echo ${nb:-123}	如果变量nb有赋值（nb=nbnbnbnbnb） 返回nbnbnbnbnb
		（默认值）		如果变量nb没有赋值，返回 123
	**	赋初始值： pass=${pass:-123456}		#如果pass为null，则pass=123456，否则pass为原有的值


	5、数组（一个变量存多个值）
		-格式： a=（11 12 22 33）
			echo ${a[0]}  11			# 获取单个属组的值
			echo ${a[@]}  11 12 22 33  	# @ 获取数组所有的值
			echo ${#a[@]} 4			# # 获取数组元素个数
			echo ${数组名[@]：起始下标：元素个数}
	
二、自动交互软件 expect		## expect有bug毛病，最后一行不执行退出，所以最后一行不是用来做操作的
	1).基本语法格式：
		·expect的核心是spawn expect send set
		·spawn 调用要执行的命令
		·expect 等待命令提示信息的出现，也就是捕捉用户输入的提示：
		·send 发送需要交互的值，替代了用户手动输入内容
		·set 设置变量值
	例子：
		vim ssh.sh
		#!/bin/bash
		  expect <<EOF
		  spawn ssh -o StrictHostKeyChecking=no 172.25.0.10	#-o选项 自动yes同意
		 								 #expect "(yes/no)"   {send "yes\n"}
		  expect "password"   {send "Taren1\n"}
		  expect "#"   {send "ping -c3 -w 0.1 -i 0.2 www.baidu.com\n"}
		  expect "#"   {send "echo $?\n"}	
		  expect "0"   {send "firefox\n"}		#最后一行不执行退出 
		  EOF


三、正则表达式：[ 特殊符号来表达的一种形式 ]，计算机的通用表达式

	1).egrep过滤工具		#支持扩展正则，grep不支持扩展正则


***	2).基本正则

		^  ：开始
		$  ：结尾
		[ ] ：集合，取任意单个字符		#[ate9] 取任意单个字符匹配a t e 9；如[a-z]，[0-9]
		[^] ：对集合取反			#[^a-z],匹配除小写字母之外的所有
		.  ：任意单个字符
		*  ：匹配前一个字符任意次[*不允许单独使用
		.* ：通配符，匹配所有

		\{n,m\}  ：匹配前一个字符n到m次		#a\{3,5\}  匹配3-5个a
		\{n,\}   ：匹配前一个字符n次以及以上	#a\{3,\}  匹配3个a以上，上不封顶
		\{n\}	   ：匹配前一个字符n次		#a\{3\}  匹配3个a
		\(\)	    ：保留		#（ab）（cccc）（ddd） \1:(ab)  \2:(cccc)  \3:(ddd)

***	3).扩展正则（简化，加）

		+  ：前面的内容出现了1次或以上
		？  ：前面的内容出现了0次或1次
		()  ：组合为整体，保留（abc）
		|   ：或者（test|taste）
		\b ：单词边界		#\bthe\b,the前面和后面没有其他字符；\bthe：the前面没字符；the\b：后面没有字符
		\< ：开始
		\> ：结尾
		{n,m}  ：匹配n-m次
		{n,}	 ：匹配n次及以上
		{n}	 ：匹配n次


基本正则：兼容性强（所有软件都支持），复杂
扩展正则：兼容性差（不是所有软件都支持），简单


___________________________________________________________________________
————————————————————————————————————————————————————————————


3月29号 day05




一、sed文本编辑器（vim、notepad、world、wps）
    sed(非交互)：sed逐行处理
	
	1.用法：
		1).前置命令 | sed [选项] '条件指令'			#指令：增 删 改 查

		2).sed [选项] '条件指令'  文件...			#sed（对后面对象文件进行）逐行处理

	2.sed工具的基本选项
	
	  -n :屏蔽默认输出,默认sed会输出读取文档的全部内容
		
		sed -n '3p' /etc/passwd  	#只打印第三行的内容， 条件：3 指令：p(print)
		sed '3p' /etc/passwd		#会显示全部内容，第三行会再打印一遍
		sed -n '3,6p' /etc/passwd	#打印3-6行的内容

	  -r :让sed支持扩展正则  #默认不能用扩展正则，要加-r才能用扩展	

  **	  -i :sed直接修改源文件

		sed 'd' /etc/passwd		#删除全部内容，d(delete)，但是没加-i是临时修改（内存）
		cat /etc/passwd			#/etc/passwd还在
		sed -i '1,4d' test.txt		#删除源文件1-4行的内容
		cat test.txt			#查看原有的1-4行已删除了
		
		sed -i '$d' a.txt			#最后一行删除


	4.sed工具的条件
		
		1).行号	sed -n '3,+10p' /文件		#打印第三行和之后的10行 3-13行的内容
				sed -n '3,6p' /etc/passwd	#打印3-6行的内容
				sed -n '1～2p' /etc/passwd	#从第一行开始每隔两行输出，奇数行
				sed -n '2～2p' /etc/passwd	#从第二行开始每隔两行输出，偶数行
			sed允许多个指令，指令间用；（分号）隔开
				sed -n '1p;3p;6p' /etc/passwd		#打印查看第1，3，6行
				sed -n '$=' /etc/passwd			#打印总共多少行


		2)./正则/	sed -n '/root/p' /etc/passwd	#打印有root的行
				sed -n '/bash$/p' /etc/passwd	#打印以bash结尾的行

  **	转义符\：sed 's9\9\98\99\976\99' 文件	#9989 换为9769
   **	替换操作的分隔“/”可改用其他字符，如#、&等，便于修改文件路径
  **	sed 's#/bin/bash#/sbin/sh#' /etc/passwd	#写路径/bin/bash时  可以用别的特殊符号代替（#、&等）

		 sed -r		
	
	5.sed工具的指令：
	**	p：(print)  打印
	**	d：(delete) 删除
	**	s：(s/old/new/g) 替换
	**	i：前插入，行前插入文本	#sed '2i xx' 文本   第二行前面插入xx		
	**	a：后追加，行后插入文本	#sed 'a xx' 文本	所有行的最后追加xx
	**	c：修改整行，替换当前行
		
		sed  's/2017/xxxx/' t.txt 		#替换每一行的第一个2017为xxxx  **	没加-i只是临时的修改 
		sed  's/2017/xxxx/2' t.txt 		#替换每一行的第二个2017为xxxx
		sed  's/2017/xxxx/g' t.txt 		#替换每一行的所有2017为xxxx
		sed  's/2017//g' t.txt			#替换每一行的所有的2017为空(null)，删除所有2017 
		sed 's/.//2;s/.$//' nssw.txt		#替换每行第二个字符和最后一个字符

		sed -r 's/^(.)(.)(.*)(.)(.)$/\1\4\3\2\5/' nssw.txt 	#第二个字符和到数第二个调换位置

 ·sed的导入导出
   **	r:读取其他文件	#sed '2r /etc/hosts' a.txt  把/etc/hosts内容，导入到test.txt中的第二行后面
	#r：插入文件中的某一行的后面 上面为：如果a.txt有2行以上则，把/etc/hosts的内容写入到a.txt的第二行后面
						如果a.txt 2行以下，则匹配不到第2行的条件 不写入/etc/hosts的内容
	
   **	w:另存为		#sed '1w /root/new.txt' a.txt 把a.txt的第一行另存为/root/new.txt

 ·sed的复制剪切									没有new.txt时会被自动创建出来 
	模式空间，和保持空间**		#保持空间第一行默认是 ：一个回车
	复制：模式空间————>保持空间	
	粘贴：保持空间————>模式空间
   **	h:复制，覆盖模式
	H:复制，追加模式
   **	g:粘贴，覆盖模式
	G:粘贴，追加模式
	例子：  sed '2h;2d;5G' test.txt		#结果 1 3 4 5 2 6
		test.txt   -----> 1回车  2回车  3回车  4回车  5回车  6回车 		


___________________________________________________________________________
————————————————————————————————————————————————————————————



3月30号 day06

一、awk文本过滤的基本用法（awk查看文本，sed修改文本）

	1）基本操作方法	
	   -格式：awk [选项] '[条件]{指令}' 文件		#[选项]、[条件]可以加也可以不加  
	**	  awk [选项] '/正则/{指令}' 文件		#默认支持扩展正则

		 awk '{print $1,$3}' new.txt		#打印 new.txt中的 第一列和第三列 的内容
	   ·print： 是最常用的编辑指令；若有多条编辑指令，可用逗号分隔。
	
   **	2）选项 -F 可指定分隔符	#awk还识别多种单个的字符

	**	处理文本时，若未指定分隔符，则默认将空格、制表符等作为分隔符。
	     awk -F: '{print $1}' /etc/passwd		# -F: 指定：为列的分隔符	
	或者： awk -F":" '{print $1"的解释器是： "$7}' /etc/passwd
	     
	    awk -F [:/] '{print $1,$10}' /etc/passwd	# -F [:/] 以：或/为分隔符	
	
	·查看文件的行数和列数
		NR：当前行的行号
		NF：当前行的列数
	   awk -F: '{print NR,NF}' passwd.txt



   ***	过滤远程连接密码失败或成功的IP地址:		#远程登录本机的日志信息在 /var/log/secure
		
	   成功：awk '/Accepted/{print $11}' /var/log/secure
	   失败：awk '/Failed/{print $11}' /var/log/secure
	
	tailf /var/log/secure	#动态查看文件的最后10行 tail静态查看最后10行



###################################################################################################################


      awk  [选项]  '[条件]{指令}'  文件

      awk  [选项]  'BEGIN{指令} {指令} END{指令}' 

      BEGIN{ } 行前处理，读取文件内容前执行，指令执行1次{指令}逐行处理，读取文件过程中执行，指令执行n次
      END{ }行后处理，读取文件结束后执行，指令执行1次

         awk 'BEGIN{x=3;print x*8}'
         awk 'BEGIN{print 3.5*8.2}'
         awk 'BEGIN{print x*8}'
         awk 'BEGIN{print 2**3}'

  awk 'BEGIN{x=0}/bash$/{x++}END{print x}' /etc/passwd  #统计passwd文件里面以bash结尾的有几个 

  awk 'BEGIN{print "用户","UID","加目录"}{print $1,$3,$6} END{print "总行数：",NR}' /etc/passwd
 



	awk选项：
		-F 自定义分隔符
		-v 自定义变量 -v 变量名=值
	

	指令：
		无  ：输出全部
		{print $1 $2 $3 .. NF NR}


  **		awk 选项 'BEGIN{指令0；指令1；指令2} {指令} END{指令0；指令1；指令2}' 文件
 	  BEGIN{ }行前处理，读取文件第一行内容前执行，指令执行1次{指令}逐行处理，读取文件过程中执行，指令执行n次
         END{ }行后处理，读取文件结束后执行，指令执行1次

	BEGIN{}:一般用来初始化
	END{}:一般用来处理输出结果

  awk 'BEGIN{x=0}/bash$/{x++}END{print x}' /etc/passwd  #统计passwd文件里面以bash结尾的有几个 
  awk 'BEGIN{print "用户","UID","加目录"}{print $1,$3,$6} END{print "总行数：",NR}' /etc/passwd
 


	条件：
		1).正则 ： //  $1~//  $7!~//		~：匹配   !~：不匹配
		2).数字或字符 ： ==  != > >= < <=
		3).逻辑判断： && ||
		4).算术运算： ++ -- += -= + - * / %

	   无条件： awk '{print $4}' 文件
	   有条件： awk '/root/{print $4}' 文件
	   精确条件： awk -F: '$1=="root"' 文件
		     awk -F: '$1>100 && $3<200' 文件
		     awk -F: '$1==0 || $3==1000' 文件
		seq 300 | awk '$1%3==0'	#seq 逐行处理

	   有选项条件无指令： awk -F: '$1~/root/' 文件
	   有选项条件有指令： awk -F: '$7~/bash$/{print $1}' 文件


	if语句：
		单分支： if(条件){指令}

		双分支： if(条件){指令1}else{指令2}

		多分支： if(条件){指令1}else if(条件){指令2}...else{指令n}


  ***	awk公式
		
	·数组： 	awk 'BEGIN{a[0]=11;a[1]=88;print a[1],a[0]}' 文件




